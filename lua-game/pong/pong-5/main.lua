--[[
    Autor: Tiago Henrique
    tiagohs.dev@gmail.com

    Exercício do curso de desenvolvimento de jogos
    CS50 - Instrutor Colton Ogden - cogden@cd50.harvard.edu

    Originalmente programado Nolan Bushnell e Ted Dabney
    na forma de console ligado a um monitor movido a fichas,
    "Pong" foi o primeiro game lucrativo da história dando
    origem a fundação da empresa Atari, em 1972 e a um novo
    setor da industria.

    O game em duas dimensões, simula tênis de mesa onde dois
    jogadores têm o objetivo de mandar a bola além da borda do
    seu oponente. Vence o primeiro a marcar 10 pontos.

    Esta versão é construída para se parecer mais com o NES do que
    as máquinas Pong originais ou o Atari 2600 em termos de
    resolução, embora em widescreen (16: 9) para que fique mais
    bonito em sistemas modernos.
    ]] --
-- push é uma biblioteca que nos permite desenhar o jogo em um ambiente virtual
-- resolução, em vez do "tamanho" da janela;
-- usado para uma estética mais retrô
-- https://github.com/Ulydev/push
push = require 'push'

-- a biblioteca "Class" usada permitirá representar qualquer  as raquetes e a bola no game
-- ao invés de acompanhar muitas variáveis e métodos díspares
-- https://github.com/vrld/hump/blob/master/class.lua
Class = require 'class'

-- A classe da Raquete, que armazena suas dimensões e posições, além da lógica 
-- para renderizá-las
require 'Paddle'

-- A  classe Bola, que não é muito diferente da classe Raquete, mas que, 
-- mecanicamente, funcionará muito diferente.
require 'Ball'

WINDOW_WIDTH = 1280
WINDOW_HEIGHT = 720

VIRTUAL_WIDTH = 432
VIRTUAL_HEIGHT = 243

PADDLE_SPEED = 200

function love.load()
    love.graphics.setDefaultFilter('nearest', 'nearest')

    math.randomseed(os.time())

    smallFont = love.graphics.newFont('font.ttf', 8)

    love.graphics.setFont(smallFont)

    push:setupScreen(VIRTUAL_WIDTH, VIRTUAL_HEIGHT, WINDOW_WIDTH, WINDOW_HEIGHT,
                     {fullscreen = false, resizable = true, vsync = true})

    -- Inicializa as raqutes dos players; armazenamos em váriáveis globais
    -- para que outras funções e módulos possam usá-las.
    player1 = Paddle(10, 30, 5, 20)
    player2 = Paddle(VIRTUAL_WIDTH - 10, VIRTUAL_HEIGHT - 30, 5, 20)

    -- Coloque a bola no centro da tela.
    ball = Ball(VIRTUAL_WIDTH / 2 - 2, VIRTUAL_HEIGHT / 2 - 2, 4, 4)

    gameState = 'start'
end

function love.update(dt)
    if love.keyboard.isDown('w') then
        player1.dy = -PADDLE_SPEED
    elseif love.keyboard.isDown('s') then
        player1.dy = PADDLE_SPEED
    else
        player1.dy = 0
    end

    if love.keyboard.isDown('up') then
        player2.dy = -PADDLE_SPEED
    elseif love.keyboard.isDown('down') then
        player2.dy = PADDLE_SPEED
    else
        player2.dy = 0
    end

    if gameState == 'play' then ball:update(dt) end

    player1:update(dt)
    player2:update(dt)
end

function love.keypressed(key)
    if key == 'escape' then
        love.event.quit()
    elseif key == 'enter' or key == 'return' then
        if gameState == 'start' then
            gameState = 'play'
        else
            gameState = 'start'

            -- novo metodo de reinicialização da bola.
            ball:reset()
        end
    end
end

function love.draw()
    push:apply('start')

    love.graphics.clear(40 / 255, 45 / 255, 52 / 255, 255 / 255)

    love.graphics.setFont(smallFont)

    if gameState == 'start' then
        love.graphics.printf('Hello Start State!', 0, 20, VIRTUAL_WIDTH,
                             'center')
    else
        love.graphics
            .printf('Hello Play State!', 0, 20, VIRTUAL_WIDTH, 'center')
    end

    -- Renderiza as raquetes, mas, agora, usando o método de renderização
    -- definido pela classe.
    player1:render()
    player2:render()

    -- Renderiza a bola,também usando o método de renderização
    -- definida na classe.
    ball:render()

    push:apply('end')
end
